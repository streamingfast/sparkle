// Code generated by sparkle. DO NOT EDIT.

package testgraph

import (
	"testing"

	"github.com/stretchr/testify/assert"

	"github.com/streamingfast/sparkle/entity"
)

func TestDefinition_MergeFunc(t *testing.T) {
	tests := []struct {
		name          string
		step          int
		currentEntity entity.Interface
		nextEntity    entity.Interface
		expect        entity.Interface
	}{
		{
			name:          "no current entity",
			step:          1,
			currentEntity: nil,
			nextEntity: &TestEntity{
				Base: entity.Base{
					ID: "test-factory-id",
				},
			},
			expect: &TestEntity{
				Base: entity.Base{
					ID: "test-factory-id",
				},
			},
		},
		//	{
		//		name: "should always return the next entity with the current merge into it",
		//		step: 1,
		//		currentEntity: &TestFactory{
		//			Base: entity.Base{
		//				ID: "test-factory-id-old",
		//			},
		//		},
		//		nextEntity: &TestFactory{
		//			Base: entity.Base{
		//				ID: "test-factory-id-new",
		//			},
		//		},
		//		expect: &TestFactory{
		//			Base: entity.Base{
		//				ID: "test-factory-id-new",
		//			},
		//		},
		//	},
		//	{
		//		name: "parallel set before set step",
		//		step: 1,
		//		currentEntity: &TestFactory{
		//			Name: "my-old-name",
		//		},
		//		nextEntity: &TestFactory{
		//			Name: "my-new-name",
		//		},
		//		expect: &TestFactory{
		//			Name: "my-old-name",
		//		},
		//	},
		//	{
		//		name: "parallel set on set step",
		//		step: 2,
		//		currentEntity: &TestFactory{
		//			Name: "my-old-name",
		//		},
		//		nextEntity: &TestFactory{
		//			Name: "my-new-name",
		//		},
		//		expect: &TestFactory{
		//			Name: "my-old-name",
		//		},
		//	},
		//	{
		//		name: "parallel set after set step not mutated",
		//		step: 3,
		//		currentEntity: &TestFactory{
		//			Name: "my-old-name",
		//		},
		//		nextEntity: &TestFactory{
		//			Base: entity.Base{
		//				MutatedOnStep: 1,
		//			},
		//			Name: "my-new-name",
		//		},
		//		expect: &TestFactory{
		//			Name: "my-old-name",
		//		},
		//	},
		//	{
		//		name: "parallel set after set step mutated",
		//		step: 3,
		//		currentEntity: &TestFactory{
		//			Name: "my-old-name",
		//		},
		//		nextEntity: &TestFactory{
		//			Base: entity.Base{
		//				MutatedOnStep: 2,
		//			},
		//			Name: "my-new-name",
		//		},
		//		expect: &TestFactory{
		//			Name: "my-new-name",
		//		},
		//	},
	}

	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			v := Definition.MergeFunc(test.step, test.currentEntity, test.nextEntity)
			assert.Equal(t, test.expect, v)
		})
	}

}
